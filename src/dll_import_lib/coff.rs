use object::pe::*;
use object::write::coff::{FileHeader, Relocation, SectionHeader, Symbol, Writer};

#[derive(Debug, Clone)]
pub(crate) enum Error {
    OutOfRange,
    Write(object::write::Error),
}

impl From<std::num::TryFromIntError> for Error {
    fn from(_: std::num::TryFromIntError) -> Self {
        Self::OutOfRange
    }
}

impl From<object::write::Error> for Error {
    fn from(value: object::write::Error) -> Self {
        Self::Write(value)
    }
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.clone() {
            Self::OutOfRange => write!(f, "value out of range"),
            Self::Write(value) => write!(f, "COFF format error: {}", value),
        }
    }
}

pub(crate) type Result<T> = std::result::Result<T, Error>;

const NULL_IMPORT_DESCRIPTOR_SYMBOL: &str = "__NULL_IMPORT_DESCRIPTOR";

/// Supported COFF machine types.
#[derive(Debug, Clone, Copy)]
pub(crate) enum Machine {
    X86_64,
}

impl Machine {
    fn as_raw(self) -> u16 {
        match self {
            Self::X86_64 => IMAGE_FILE_MACHINE_AMD64,
        }
    }

    fn relocation_type(self) -> u16 {
        match self {
            Self::X86_64 => IMAGE_REL_AMD64_ADDR32NB,
        }
    }
}

/// The IMPORT_OBJECT_* constants used to find the exported value in the DLL.
pub(crate) enum ImportNameType {
    /// No import name, import by ordinal only.
    Ordinal,
    /// Import name == public symbol name.
    Name,
    /// Import name == public symbol name skipping leading ?, @, or optionally _.
    NameNoPrefix,
    /// Import name == public symbol name skipping leading ?, @, or optionally _ and truncating at first @.
    NameUndecorate,
    #[allow(dead_code)] // not exposed by rustc_session::cstore::DllImport
    /// Import name == a name is explicitly provided after the DLL name.
    NameExportAs { export_name: String },
}

impl ImportNameType {
    fn as_u16(&self) -> u16 {
        match self {
            ImportNameType::Ordinal => IMPORT_OBJECT_ORDINAL,
            ImportNameType::Name => IMPORT_OBJECT_NAME,
            ImportNameType::NameNoPrefix => IMPORT_OBJECT_NAME_NO_PREFIX,
            ImportNameType::NameUndecorate => IMPORT_OBJECT_NAME_UNDECORATE,
            ImportNameType::NameExportAs { .. } => IMPORT_OBJECT_NAME_EXPORTAS,
        }
    }
}

/// The IMPORT_OBJECT_* constants that defines how the import is linked, or in the words of the PE
/// documentation:
/// > These values are used to determine which section contributions must be generated by the tool
/// > that uses the library if it must access that data.
/// Though it's not clear what that actually means.
#[allow(dead_code)] // only Code is used by rustc_session::cstore::DllImport
pub(crate) enum ImportType {
    Code,
    Data,
    Const,
}

impl ImportType {
    fn as_u16(&self) -> u16 {
        match self {
            ImportType::Code => IMPORT_OBJECT_CODE,
            ImportType::Data => IMPORT_OBJECT_DATA,
            ImportType::Const => IMPORT_OBJECT_CONST,
        }
    }
}

// A more directly COFF short import descriptor equivalent of rustc_session::cstore::DllImport.
pub(crate) struct Import {
    pub(crate) symbol_name: String,
    pub(crate) name_type: ImportNameType,
    pub(crate) import_type: ImportType,
    pub(crate) ordinal_or_hint: Option<u16>,
}

pub(crate) fn write_short_import(
    dll_name: &str,
    machine: Machine,
    import: &Import,
) -> Result<Vec<u8>> {
    let mut vec = Vec::new();

    let mut size_of_data = import.symbol_name.len() + 1 + dll_name.len() + 1;
    if let ImportNameType::NameExportAs { export_name } = &import.name_type {
        size_of_data += export_name.len() + 1;
    }

    fn make_u16(value: u16) -> object::endian::U16<object::endian::LittleEndian> {
        object::endian::U16::new(object::endian::LittleEndian, value)
    }

    fn make_u32(value: u32) -> object::endian::U32<object::endian::LittleEndian> {
        object::endian::U32::new(object::endian::LittleEndian, value)
    }

    vec.extend_from_slice(object::bytes_of(&ImportObjectHeader {
        sig1: make_u16(IMAGE_FILE_MACHINE_UNKNOWN),
        sig2: make_u16(IMPORT_OBJECT_HDR_SIG2),
        version: make_u16(0),
        machine: make_u16(machine.as_raw()),
        time_date_stamp: make_u32(0),
        size_of_data: make_u32(size_of_data.try_into()?),
        ordinal_or_hint: make_u16(import.ordinal_or_hint.unwrap_or_default()),
        name_type: make_u16(
            import.import_type.as_u16() << IMPORT_OBJECT_TYPE_SHIFT
                | import.name_type.as_u16() << IMPORT_OBJECT_NAME_SHIFT,
        ),
    }));
    vec.extend_from_slice(import.symbol_name.as_bytes());
    vec.push(0);
    // data.dll_name:
    vec.extend_from_slice(dll_name.as_bytes());
    vec.push(0);
    if let ImportNameType::NameExportAs { export_name } = &import.name_type {
        // data.export_name:
        vec.extend_from_slice(export_name.as_bytes());
        vec.push(0);
    }

    Ok(vec)
}

pub(crate) struct ImportDescriptorValues {
    pub(crate) dll_name: String,
    pub(crate) machine: Machine,
    pub(crate) import_descriptor_symbol: String,
    pub(crate) null_thunk_data_symbol: String,
}

impl ImportDescriptorValues {
    pub(crate) fn new(dll_name: String, machine: Machine) -> Self {
        // foo.dll => foo so we can construct the import descriptor symbol.
        // At least for the Windows system dlls, don't seem to need any further
        // escaping, e.g. "api-ms-win-appmodel-runtime-l1-1-1.dll" =>
        // "__IMPORT_DESCRIPTOR_api-ms-win-appmodel-runtime-l1-1-1"
        // Not using std::path to avoid having to handle non-unicode paths.
        let mut dll_basename = dll_name.clone();
        if let Some(index) = dll_basename.rfind('.') {
            dll_basename.truncate(index);
        }

        let import_descriptor_symbol = format!("__IMPORT_DESCRIPTOR_{dll_basename}");
        let null_thunk_data_symbol = format!("\x7f{dll_basename}_NULL_THUNK_DATA");

        Self { dll_name, machine, import_descriptor_symbol, null_thunk_data_symbol }
    }
}

/// Return a COFF object file containing the import descriptor table entry for the
/// given DLL name.
pub(crate) fn generate_import_descriptor(values: &ImportDescriptorValues) -> Result<Vec<u8>> {
    // This is a COFF object containing 2 sections:
    //   .idata$2: import directory entry:
    //      20 bytes, all 0 on disk, an Import Directory Table entry
    //      filled out by the linker with relocations.
    //   .idata$6: DLL name:
    //       The null terminated file name of the dll
    // The import directory entry has 3 relocations:
    //    0: [3] import lookup table rva => points to UNDEF symbol .idata$4
    //   12: [2] name rva => points to DLL name section .idata$6
    //   16: [4] import address table rva => points to UNDEF symbol .idata$5
    // The COFF symbol table contains 7 symbols:
    //  [0]: external __IMPORT_DESCRIPTOR_{dll_basename} => section 1
    //  [1]: section .idata$2 => section 1
    //  [2]: static .idata$6 => section 2
    //  [3]: section .idata$4 => undef
    //  [4]: section .idata$5 => undef
    //  [5]: external __NULL_IMPORT_DESCRIPTOR => undef
    //  [6]: external __NULL_THUNK_DATA => undef

    // COFF File header:
    let mut data = Vec::new();
    let mut writer = Writer::new(&mut data);

    let import_descriptor_symbol = writer.add_name(values.import_descriptor_symbol.as_bytes());
    let null_import_descriptor_symbol = writer.add_name(NULL_IMPORT_DESCRIPTOR_SYMBOL.as_bytes());
    let null_thunk_data_symbol = writer.add_name(values.null_thunk_data_symbol.as_bytes());

    let import_directory_raw_data_size = 20;
    let mut import_directory_header = SectionHeader {
        name: b".idata$2".into(),
        size_of_raw_data: import_directory_raw_data_size,
        number_of_relocations: 3,
        characteristics: IMAGE_SCN_ALIGN_4BYTES
            | IMAGE_SCN_CNT_INITIALIZED_DATA
            | IMAGE_SCN_MEM_READ
            | IMAGE_SCN_MEM_WRITE,
        ..Default::default()
    };
    let mut dll_name_header = SectionHeader {
        name: b".idata$6".into(),
        size_of_raw_data: (values.dll_name.len() + 1).try_into()?,
        characteristics: IMAGE_SCN_ALIGN_2BYTES
            | IMAGE_SCN_CNT_INITIALIZED_DATA
            | IMAGE_SCN_MEM_READ
            | IMAGE_SCN_MEM_WRITE,
        ..Default::default()
    };

    writer.reserve_file_header();
    writer.reserve_section_headers(2);

    let import_directory_raw_data_offset =
        writer.reserve_section(import_directory_header.size_of_raw_data.try_into()?);
    import_directory_header.pointer_to_raw_data = import_directory_raw_data_offset;
    let import_directory_relocations_offset =
        writer.reserve_relocations(import_directory_header.number_of_relocations.try_into()?);
    import_directory_header.pointer_to_relocations = import_directory_relocations_offset;

    let dll_name_raw_data_offset =
        writer.reserve_section(dll_name_header.size_of_raw_data.try_into()?);
    dll_name_header.pointer_to_raw_data = dll_name_raw_data_offset;

    writer.reserve_symbol_indices(7);
    writer.reserve_symtab_strtab();

    writer
        .write_file_header(FileHeader { machine: values.machine.as_raw(), ..Default::default() })?;
    writer.write_section_header(import_directory_header);
    writer.write_section_header(dll_name_header);

    // [0] section .idata$2 data
    writer.write_section_align(); // only needed for the assert
    assert_eq!(writer.len(), usize::try_from(import_directory_raw_data_offset)?);
    writer.write_section_zeroes(import_directory_raw_data_size.try_into()?);

    assert_eq!(writer.len(), usize::try_from(import_directory_relocations_offset)?);
    //   relocation 0: [3] import lookup table rva => points to UNDEF symbol .idata$4
    writer.write_relocation(Relocation {
        virtual_address: 0,
        symbol: 3,
        typ: values.machine.relocation_type(),
    });
    //   relocation 1: [2] name rva => points to DLL name section .idata$6
    writer.write_relocation(Relocation {
        virtual_address: 12,
        symbol: 2,
        typ: values.machine.relocation_type(),
    });
    //   relocation 2: [4] import address table rva => points to UNDEF symbol .idata$5
    writer.write_relocation(Relocation {
        virtual_address: 16,
        symbol: 4,
        typ: values.machine.relocation_type(),
    });

    // [1] section .idata$6 data
    writer.write_section_align();
    assert_eq!(writer.len(), usize::try_from(dll_name_raw_data_offset)?);
    writer.write(values.dll_name.as_bytes());
    writer.write(&[0u8]);

    // COFF symbol table:
    writer.write_symbol(Symbol {
        name: import_descriptor_symbol,
        section_number: 1,
        storage_class: IMAGE_SYM_CLASS_EXTERNAL,
        ..Default::default()
    });
    writer.write_symbol(Symbol {
        name: b".idata$2".into(),
        section_number: 1,
        storage_class: IMAGE_SYM_CLASS_SECTION,
        ..Default::default()
    });
    writer.write_symbol(Symbol {
        name: b".idata$6".into(),
        section_number: 2,
        storage_class: IMAGE_SYM_CLASS_STATIC,
        ..Default::default()
    });
    writer.write_symbol(Symbol {
        name: b".idata$4".into(),
        storage_class: IMAGE_SYM_CLASS_SECTION,
        ..Default::default()
    });
    writer.write_symbol(Symbol {
        name: b".idata$5".into(),
        storage_class: IMAGE_SYM_CLASS_SECTION,
        ..Default::default()
    });
    writer.write_symbol(Symbol {
        name: null_import_descriptor_symbol,
        storage_class: IMAGE_SYM_CLASS_EXTERNAL,
        ..Default::default()
    });
    writer.write_symbol(Symbol {
        name: null_thunk_data_symbol,
        storage_class: IMAGE_SYM_CLASS_EXTERNAL,
        ..Default::default()
    });
    writer.write_strtab();

    Ok(data)
}

pub(crate) fn generate_null_thunk_data(machine: Machine, symbol: &str) -> Result<Vec<u8>> {
    let mut data = Vec::new();

    let mut writer = Writer::new(&mut data);
    // This is a COFF file with a two sections with 8 bytes of null data
    let symbol = writer.add_name(symbol.as_bytes());

    let import_address_section_size = 8;
    let import_lookup_section_size = 8;
    let mut import_address_header = SectionHeader {
        name: b".idata$5".into(),
        size_of_raw_data: import_address_section_size,
        characteristics: IMAGE_SCN_ALIGN_8BYTES
            | IMAGE_SCN_CNT_INITIALIZED_DATA
            | IMAGE_SCN_MEM_READ
            | IMAGE_SCN_MEM_WRITE,
        ..Default::default()
    };
    let mut import_lookup_header = SectionHeader {
        name: b".idata$4".into(),
        size_of_raw_data: import_lookup_section_size,
        characteristics: IMAGE_SCN_ALIGN_8BYTES
            | IMAGE_SCN_CNT_INITIALIZED_DATA
            | IMAGE_SCN_MEM_READ
            | IMAGE_SCN_MEM_WRITE,
        ..Default::default()
    };

    writer.reserve_file_header();
    writer.reserve_section_headers(2);
    let import_address_raw_data_offset =
        writer.reserve_section(import_address_header.size_of_raw_data.try_into()?);
    import_address_header.pointer_to_raw_data = import_address_raw_data_offset;
    let import_lookup_raw_data_offset =
        writer.reserve_section(import_lookup_header.size_of_raw_data.try_into()?);
    import_lookup_header.pointer_to_raw_data = import_lookup_raw_data_offset;
    writer.reserve_symbol_indices(1);
    writer.reserve_symtab_strtab();

    writer.write_file_header(FileHeader { machine: machine.as_raw(), ..Default::default() })?;
    writer.write_section_header(import_address_header);
    writer.write_section_header(import_lookup_header);

    writer.write_section_zeroes(import_address_section_size.try_into()?);
    writer.write_section_zeroes(import_lookup_section_size.try_into()?);

    writer.write_symbol(Symbol {
        name: symbol,
        section_number: 1,
        storage_class: IMAGE_SYM_CLASS_EXTERNAL,
        ..Default::default()
    });
    writer.write_strtab();
    drop(writer);

    Ok(data)
}

/// Return the COFF object file containing the "Null Import Descriptor" symbols,
/// used by the linker to terminate the import descriptor table in .idata.
/// At least one of these must exist across the linker input files.
pub(crate) fn generate_null_import_descriptor(machine: Machine) -> Result<Vec<u8>> {
    let mut data = Vec::new();
    let mut writer = Writer::new(&mut data);

    // This is a COFF file with a section with 20 bytes of null data
    let null_import_descriptor_symbol = writer.add_name(NULL_IMPORT_DESCRIPTOR_SYMBOL.as_bytes());

    let import_descriptor_size = 20;
    let mut import_descriptor_header = SectionHeader {
        name: b".idata$3".into(),
        size_of_raw_data: import_descriptor_size,
        characteristics: IMAGE_SCN_ALIGN_4BYTES
            | IMAGE_SCN_CNT_INITIALIZED_DATA
            | IMAGE_SCN_MEM_READ
            | IMAGE_SCN_MEM_WRITE,
        ..Default::default()
    };

    writer.reserve_file_header();
    writer.reserve_section_headers(1);
    let import_descriptor_raw_data_offset =
        writer.reserve_section(import_descriptor_header.size_of_raw_data.try_into()?);
    import_descriptor_header.pointer_to_raw_data = import_descriptor_raw_data_offset;
    writer.reserve_symbol_indices(1);
    writer.reserve_symtab_strtab();

    writer.write_file_header(FileHeader { machine: machine.as_raw(), ..Default::default() })?;
    writer.write_section_header(import_descriptor_header);

    writer.write_section_zeroes(import_descriptor_size.try_into()?);

    writer.write_symbol(Symbol {
        name: null_import_descriptor_symbol,
        section_number: 1,
        storage_class: IMAGE_SYM_CLASS_EXTERNAL,
        ..Default::default()
    });
    writer.write_strtab();

    drop(writer);

    Ok(data)
}
